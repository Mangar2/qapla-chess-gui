code style: comment method declaration in jsdoc. Use c++20. Min. id length=3. Use ranges. Use format. Use nodiscard. Only "why comments". Max. Method complexity level 20. Max. nesting lelvel 3.
code style: prevent implicit conversions use same types where possible. Always use curly braces for all control statements. Use "auto" instead of the type where reasonable especially if the type is already in the line.

imgui: dont use imgui controls directy use controls from imguicontrols.h

code style: comment method declaration in jsdoc. Use c++20. Min. id length=3. Use ranges. Use format. Use nodiscard. Only "why comments". Max. Method complexity level 20. 
Bitte verändere das laden und speichern der language-files und der missing translations wie folgt:
1. Translation muss immer auch ein Topic bekommen. Ein topic ist ein string zu dem die Übersetzung gehört, z.B. "Button" oder "Tab". Damit können wir gleiche strings an unterschiedlichen stellen auch unerschiedlich übersetzen.
2. Nutze das ini format zum laden und speichern von language dateien und missing translations. Schaue dir dazu configuration.h/.cpp an wie das funktioniert.
3. Nutze als name "Translation" und als "id" den topic.  
Hinweis: die sprachdateien in i18n hab ich schon manuell auf das neue format umgestellt. 

Baue einen "eröffnungs-parser" (opening-parser.h/.cpp) im verzeichnis extern/qapla-engine-tester. 
Er soll  eine datei mit verschiedenen möglichen formaten einlesen und als std::vector<GameRecord> zurückgeben. 
Orientiere Dich von der struktur an game-parser.cpp, d.h. es muss die möglichkeit geben verschiedene parser zu registrieren
Die Reihenfolge mit der Parser ausprobiert werden orientiert sich zunächst an der Dateiendung und danach an der reihenfolge wie die parser hinzugefügt wurden
Implementiere zunächst genau einen parser, der PGN - Parser da der schon vorhanden ist. 
code style: comment method declaration in jsdoc. Use c++20. Min. id length=3. Use ranges. Use format. Use nodiscard. Only "why comments". Max. Method complexity level 20. Max. nesting lelvel 3.
code style: prevent implicit conversions use same types where possible. Always use curly braces for all control statements. Use "auto" instead of the type where reasonable especially if the type is already in the line.


Ich baue eine schach-gui mit Dear ImGUI. Sie funktioniert ist aber - so ein user feedback zu kompliziert. 
Meine Idee ist nun einen weiteren einfacheren Zugang zur selben funktionalität hinzuzufügen. 
Der Fensterinhalt soll wie eine art chat-bot funktionieren - allerdings nur mit festen optionen, nicht mit mit echtem Text. 
Bitte erstelle zunächst dazu ein chatbot-window.h/.cpp das von EmbeddedWindow erbt und den chat-ablauf anzeigt. 
Es muss chatbot-thread elemente nutzen können weche den ablauf steuern. Das EmbeddedWindow wird alle treads als optionen anbieten.
Wenn der nutzer dann einen thread auswählt, wird der gestartet - erstelle dafür also eine basisklasse in einer extra datei,
von der alle implementierten threads erben und das die nötigen pur virtuellen basisklassen hat, damit ChatbotWindow sie nutzen kann.
Ein Chatbot thread wiederum besteht aus ChatBot steps, die jeweils einen step umsetzen. Erstelle auch für einen Chatbot-step 
eine basisklasse, die nötige pur virtuellen methoden enthält soweit schon jetzt klar ist. Implementiere als ersten chatbot-step 
dann einen der Eine Liste von Optionen anzeigt und den benutzer eine der optionen auswählen lässt. 
Baue dann in ChatbotWindow als erstes diesen ChatbotStep ein, der den benutzer die bisher im ChatbotWindow registrierten threads 
auswählen lässt (threads müssen im ChatbotWindow registriert werden, das ChatbotWindow kennt also nur die Basisklasse ChatbotThread und ChatbotStep nicht deren ausprägung)
Baue dann einen ersten Thread chatbot-choose-language der inhaltlich komplett leer bleibt und direkt wieder zurückgeht. 
Das ChatbotWindow muss sich alle abgeabeiteten Threads merken. Es wird die fertigen hinter ein collapable stecken so dass der 
Benutzer nachträglich sehen kann, was gemacht wurde, wenn er will.
code style: comment method declaration in jsdoc. Use c++20. Min. id length=3. Use ranges. Use format. Use nodiscard. Only "why comments". Max. Method complexity level 20. Max. nesting lelvel 3.
code style: prevent implicit conversions use same types where possible. Always use curly braces for all control statements. Use "auto" instead of the type where reasonable especially if the type is already in the line.

Nun vervollständige den thread choose language. Wie das auswählen einer sprache geht findest du in configuration-window "drawLanguageConfig". Setze das aber im step als options um nicht als dropdown-box. 
Erstelle zunächst ein option control in imgui-controls incl. Übersetzung ( auto translatedText = Translator::instance().translate("Option", text);)
Nutze die dann zur auswahl der sprache. Baue dafür einen chatbot-option step der genutzt wird. 
Baue die übersetzung in alle strings ein die du im chatbot ausgibts. Insgesamt sollten wir danach einen fertigen ersten threadh
haben der uns die Sprache setzen läst und der sich dann mit einem netten Abschlusswort verabschiedet und ein "Finish" anbietet der den Thread dann beendet.
Baue auch für das "Finishing" einen eigenen Step.
code style: comment method declaration in jsdoc. Use c++20. Min. id length=3. Use ranges. Use format. Use nodiscard. Only "why comments". Max. Method complexity level 20. Max. nesting lelvel 3.
code style: prevent implicit conversions use same types where possible. Always use curly braces for all control statements. Use "auto" instead of the type where reasonable especially if the type is already in the line.

Bitte erstelle nun einen neuen thread zum erstellen eines schach turniers. Die schritte sind:
1. Auswahl ob man das bestehende Turnier speichern möchte
2. Auswählen von Engines aus einer Liste von vorhandenen Engines (überspringen, wenn keine engines vorhanden sind).
3. Möglichkeit anbieten weitere Engines zu laden bis "will nicht weitere" ausgewählt wird. 
4. Auswahl der Zeitkontrolle
5. Auswahl der Global-Engine-options
6. Auswahl des Turniertyps, Rundenzahl, Spiele pro Runde
7. Auswahl der Datei mit Startpositionen
8. Auswahl der PGN-Speicher-Optionen
9. Auswahl der Anzahl parallel laufenden Spiele
10. Auswahl ob man das Turnier starten, speichern oder weitere Details ändern will (Nach starten wird der finish schritt übersprungen)
11. Finish mit Ende-Meldung, wenn das Turnier nicht gestartet wurde. Details ändern kann man dann über die vorhandenen eingabemöglichkeiten im Turnier-Tab bitte darauf hinweisen.
Bitte erstelle den Thread und die ersten drei Steps. Wie das funktioniert findest du in tournament-window und tournament-data